<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvEm - Cancelable Events & Errors Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            opacity: 0.9;
            display: inline-block;
            margin-top: 10px;
        }

        .nav-link:hover {
            opacity: 1;
        }

        .demo-section {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .demo-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .demo-section p {
            color: #666;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background: #48bb78;
        }

        button.secondary:hover {
            background: #38a169;
        }

        button.danger {
            background: #f56565;
        }

        button.danger:hover {
            background: #e53e3e;
        }

        .output {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 6px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .output .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .output .timestamp {
            color: #718096;
        }

        .output .event-name {
            color: #48bb78;
            font-weight: bold;
        }

        .output .data {
            color: #fbd38d;
        }

        .output .info {
            color: #63b3ed;
        }

        .output .success {
            color: #48bb78;
        }

        .output .error {
            color: #fc8181;
        }

        .output .warning {
            color: #f6ad55;
        }

        .output .cancelled {
            color: #f093fb;
        }

        .code-block {
            background: #2d3748;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            color: #e2e8f0;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-box {
            background: #edf2f7;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-box .label {
            color: #718096;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .stat-box .value {
            color: #667eea;
            font-size: 1.8rem;
            font-weight: bold;
        }

        .stat-box.success .value {
            color: #48bb78;
        }

        .stat-box.cancelled .value {
            color: #f093fb;
        }

        .stat-box.error .value {
            color: #f56565;
        }

        .handler-chain {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #edf2f7;
            border-radius: 6px;
            flex-wrap: wrap;
        }

        .handler-box {
            flex: 1;
            min-width: 120px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .handler-box.executed {
            background: #c6f6d5;
            border: 2px solid #48bb78;
        }

        .handler-box.cancelled {
            background: #fed7d7;
            border: 2px solid #f56565;
            opacity: 0.6;
        }

        .handler-box .handler-name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #667eea;
        }

        .handler-box .handler-status {
            font-size: 0.85rem;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üõë Cancelable Events & Errors Demo</h1>
            <p>Event cancellation and error policy management</p>
            <a href="../index.html" class="nav-link">‚Üê Back to demos</a>
        </header>

        <div class="demo-section">
            <h2>1. Cancelable Events</h2>
            <p>Handlers can prevent event propagation</p>
            <div class="code-block">evem.publishCancelable('user.delete', data).then(result => {
    if (result.cancelled) {
        console.log('Event was cancelled by:', result.cancelledBy);
    }
});</div>
            <div class="controls">
                <button onclick="setupCancelable()">Setup Cancelable Event</button>
                <button class="secondary" onclick="publishAllowed()">Publish Allowed</button>
                <button class="secondary" onclick="publishDenied()">Publish Denied</button>
            </div>
        </div>

        <div class="demo-section">
            <h2>2. Error Policies</h2>
            <p>Configure how errors in handlers are managed</p>
            <div class="code-block">// continue: Continue to next handlers
// stop: Stop at first error
// collect: Collect all errors and report</div>
            <div class="controls">
                <button onclick="setPolicy('continue')">Policy: Continue</button>
                <button onclick="setPolicy('stop')">Policy: Stop</button>
                <button onclick="setPolicy('collect')">Policy: Collect</button>
                <button class="secondary" onclick="publishWithErrors()">Publish with Errors</button>
            </div>
            <div id="policyDisplay" style="margin-top: 10px; color: #667eea; font-weight: bold;">
                Current Policy: continue
            </div>
        </div>

        <div class="demo-section">
            <h2>3. Validation Chains</h2>
            <p>Multiple validators in sequence, any can cancel</p>
            <div id="validationChain" class="handler-chain"></div>
            <div class="controls">
                <button onclick="setupValidationChain()">Setup Chain</button>
                <button class="secondary" onclick="testValidChain()">Valid Data</button>
                <button class="secondary" onclick="testInvalidChain()">Invalid Data</button>
                <button class="danger" onclick="resetChain()">Reset</button>
            </div>
        </div>

        <div class="demo-section">
            <h2>4. Permission Checks</h2>
            <p>Use cancelable events for permission validation</p>
            <div class="controls">
                <button onclick="setupPermissions()">Setup Permissions</button>
                <button class="secondary" onclick="adminAction()">Admin Action</button>
                <button class="secondary" onclick="userAction()">User Action</button>
            </div>
        </div>

        <div class="demo-section">
            <h2>5. Error Recovery</h2>
            <p>Handle errors gracefully with fallback logic</p>
            <div class="controls">
                <button onclick="setupErrorRecovery()">Setup Recovery</button>
                <button class="secondary" onclick="triggerRecovery()">Trigger with Error</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-box success">
                <div class="label">Successful Events</div>
                <div class="value" id="successCount">0</div>
            </div>
            <div class="stat-box cancelled">
                <div class="label">Cancelled Events</div>
                <div class="value" id="cancelledCount">0</div>
            </div>
            <div class="stat-box error">
                <div class="label">Errors Caught</div>
                <div class="value" id="errorCount">0</div>
            </div>
        </div>

        <div class="output" id="output"></div>
    </div>

    <script type="module">
        class CancelableEvent {
            constructor(name, data) {
                this.name = name;
                this.data = data;
                this.cancelled = false;
                this.cancelledBy = null;
                this.errors = [];
            }

            cancel(reason) {
                this.cancelled = true;
                this.cancelledBy = reason;
            }
        }

        class EvEm {
            constructor() {
                this.events = new Map();
                this.subscriptionCounter = 0;
                this.errorPolicy = 'continue'; // continue, stop, collect
            }

            setErrorPolicy(policy) {
                this.errorPolicy = policy;
            }

            subscribe(event, callback, options = {}) {
                const id = `sub-${++this.subscriptionCounter}`;
                if (!this.events.has(event)) {
                    this.events.set(event, new Map());
                }
                this.events.get(event).set(id, { callback, options });
                return id;
            }

            async publish(event, data) {
                const handlers = [];
                if (this.events.has(event)) {
                    handlers.push(...Array.from(this.events.get(event).values()));
                }

                const errors = [];

                for (const handler of handlers) {
                    try {
                        await handler.callback(data);
                    } catch (error) {
                        window.errorCount++;
                        updateStats();

                        if (this.errorPolicy === 'stop') {
                            log(`<span class="error">Error in handler, stopping:</span> ${error.message}`, 'error');
                            throw error;
                        } else if (this.errorPolicy === 'collect') {
                            errors.push(error);
                            log(`<span class="warning">Error collected:</span> ${error.message}`, 'warning');
                        } else {
                            log(`<span class="warning">Error in handler, continuing:</span> ${error.message}`, 'warning');
                        }
                    }
                }

                if (this.errorPolicy === 'collect' && errors.length > 0) {
                    const errorReport = {
                        event,
                        errors: errors.map(e => e.message)
                    };
                    log(`<span class="error">Error report:</span> ${errors.length} errors collected`, 'error');
                    return errorReport;
                }

                return true;
            }

            async publishCancelable(event, data) {
                const cancelableEvent = new CancelableEvent(event, data);
                const handlers = [];

                if (this.events.has(event)) {
                    handlers.push(...Array.from(this.events.get(event).values()));
                }

                for (const handler of handlers) {
                    if (cancelableEvent.cancelled) {
                        log(`<span class="cancelled">Remaining handlers skipped</span> due to cancellation`, 'cancelled');
                        break;
                    }

                    try {
                        await handler.callback(cancelableEvent);
                    } catch (error) {
                        window.errorCount++;
                        updateStats();
                        log(`<span class="error">Error in handler:</span> ${error.message}`, 'error');
                    }
                }

                if (cancelableEvent.cancelled) {
                    window.cancelledCount++;
                } else {
                    window.successCount++;
                }
                updateStats();

                return {
                    cancelled: cancelableEvent.cancelled,
                    cancelledBy: cancelableEvent.cancelledBy,
                    data: cancelableEvent.data
                };
            }
        }

        // Global state
        window.evem = new EvEm();
        window.successCount = 0;
        window.cancelledCount = 0;
        window.errorCount = 0;
        window.currentPolicy = 'continue';
        window.currentRole = 'user';

        // Logging utility
        window.log = (message, type = 'info') => {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
            output.appendChild(entry);
            output.scrollTop = output.scrollHeight;
        };

        window.updateStats = () => {
            document.getElementById('successCount').textContent = window.successCount;
            document.getElementById('cancelledCount').textContent = window.cancelledCount;
            document.getElementById('errorCount').textContent = window.errorCount;
        };

        // Demo functions
        window.setupCancelable = () => {
            window.evem.subscribe('user.delete', (event) => {
                log(`Validator 1: Checking if user exists...`, 'info');
                if (!event.data.userId) {
                    event.cancel('Missing userId');
                    log(`<span class="cancelled">Cancelled by Validator 1:</span> Missing userId`, 'cancelled');
                }
            });

            window.evem.subscribe('user.delete', (event) => {
                log(`Validator 2: Checking permissions...`, 'info');
                if (!event.data.confirmed) {
                    event.cancel('Deletion not confirmed');
                    log(`<span class="cancelled">Cancelled by Validator 2:</span> Not confirmed`, 'cancelled');
                }
            });

            window.evem.subscribe('user.delete', (event) => {
                log(`Handler: Deleting user ${event.data.userId}...`, 'success');
            });

            log('Cancelable event setup complete', 'info');
        };

        window.publishAllowed = async () => {
            log('Publishing with valid data...', 'info');
            const result = await window.evem.publishCancelable('user.delete', {
                userId: 123,
                confirmed: true
            });

            if (result.cancelled) {
                log(`<span class="cancelled">Event cancelled by:</span> ${result.cancelledBy}`, 'cancelled');
            } else {
                log(`<span class="success">Event completed successfully</span>`, 'success');
            }
        };

        window.publishDenied = async () => {
            log('Publishing with invalid data...', 'info');
            const result = await window.evem.publishCancelable('user.delete', {
                userId: 456,
                confirmed: false
            });

            if (result.cancelled) {
                log(`<span class="cancelled">Event cancelled by:</span> ${result.cancelledBy}`, 'cancelled');
            } else {
                log(`<span class="success">Event completed successfully</span>`, 'success');
            }
        };

        window.setPolicy = (policy) => {
            window.evem.setErrorPolicy(policy);
            window.currentPolicy = policy;
            document.getElementById('policyDisplay').textContent = `Current Policy: ${policy}`;
            log(`Error policy changed to: <span class="warning">${policy}</span>`, 'info');
        };

        window.publishWithErrors = async () => {
            // Clear previous subscriptions
            window.evem.events.set('error.test', new Map());

            window.evem.subscribe('error.test', () => {
                log('Handler 1: Success', 'success');
            });

            window.evem.subscribe('error.test', () => {
                log('Handler 2: Throwing error...', 'warning');
                throw new Error('Handler 2 failed');
            });

            window.evem.subscribe('error.test', () => {
                log('Handler 3: Success', 'success');
            });

            window.evem.subscribe('error.test', () => {
                log('Handler 4: Throwing error...', 'warning');
                throw new Error('Handler 4 failed');
            });

            try {
                await window.evem.publish('error.test', {});
            } catch (error) {
                log(`<span class="error">Publish threw error:</span> ${error.message}`, 'error');
            }
        };

        window.setupValidationChain = () => {
            const chain = document.getElementById('validationChain');
            chain.innerHTML = `
                <div class="handler-box" id="validator1">
                    <div class="handler-name">Length Check</div>
                    <div class="handler-status">Waiting...</div>
                </div>
                <div class="handler-box" id="validator2">
                    <div class="handler-name">Format Check</div>
                    <div class="handler-status">Waiting...</div>
                </div>
                <div class="handler-box" id="validator3">
                    <div class="handler-name">Uniqueness Check</div>
                    <div class="handler-status">Waiting...</div>
                </div>
                <div class="handler-box" id="finalHandler">
                    <div class="handler-name">Save Data</div>
                    <div class="handler-status">Waiting...</div>
                </div>
            `;

            window.evem.events.set('data.validate', new Map());

            window.evem.subscribe('data.validate', (event) => {
                const box = document.getElementById('validator1');
                if (event.data.value.length < 3) {
                    event.cancel('Value too short');
                    box.className = 'handler-box cancelled';
                    box.querySelector('.handler-status').textContent = '‚úó Too short';
                } else {
                    box.className = 'handler-box executed';
                    box.querySelector('.handler-status').textContent = '‚úì Passed';
                }
            });

            window.evem.subscribe('data.validate', (event) => {
                const box = document.getElementById('validator2');
                if (!/^[a-zA-Z]+$/.test(event.data.value)) {
                    event.cancel('Invalid format (letters only)');
                    box.className = 'handler-box cancelled';
                    box.querySelector('.handler-status').textContent = '‚úó Invalid format';
                } else {
                    box.className = 'handler-box executed';
                    box.querySelector('.handler-status').textContent = '‚úì Passed';
                }
            });

            window.evem.subscribe('data.validate', (event) => {
                const box = document.getElementById('validator3');
                const forbidden = ['admin', 'root', 'system'];
                if (forbidden.includes(event.data.value.toLowerCase())) {
                    event.cancel('Reserved word');
                    box.className = 'handler-box cancelled';
                    box.querySelector('.handler-status').textContent = '‚úó Reserved';
                } else {
                    box.className = 'handler-box executed';
                    box.querySelector('.handler-status').textContent = '‚úì Passed';
                }
            });

            window.evem.subscribe('data.validate', (event) => {
                const box = document.getElementById('finalHandler');
                box.className = 'handler-box executed';
                box.querySelector('.handler-status').textContent = '‚úì Saved';
            });

            log('Validation chain setup complete', 'info');
        };

        window.testValidChain = async () => {
            log('Testing with valid input: "TestUser"', 'info');
            const result = await window.evem.publishCancelable('data.validate', { value: 'TestUser' });
            if (result.cancelled) {
                log(`<span class="cancelled">Validation failed:</span> ${result.cancelledBy}`, 'cancelled');
            } else {
                log(`<span class="success">All validations passed!</span>`, 'success');
            }
        };

        window.testInvalidChain = async () => {
            log('Testing with invalid input: "ab"', 'info');
            const result = await window.evem.publishCancelable('data.validate', { value: 'ab' });
            if (result.cancelled) {
                log(`<span class="cancelled">Validation failed:</span> ${result.cancelledBy}`, 'cancelled');
            } else {
                log(`<span class="success">All validations passed!</span>`, 'success');
            }
        };

        window.resetChain = () => {
            const boxes = document.querySelectorAll('.handler-box');
            boxes.forEach(box => {
                box.className = 'handler-box';
                box.querySelector('.handler-status').textContent = 'Waiting...';
            });
            log('Chain reset', 'info');
        };

        window.setupPermissions = () => {
            window.evem.events.set('admin.action', new Map());

            window.evem.subscribe('admin.action', (event) => {
                log(`Permission check: User role is <span class="data">${event.data.role}</span>`, 'info');
                if (event.data.role !== 'admin') {
                    event.cancel('Insufficient permissions');
                    log(`<span class="cancelled">Access denied:</span> Admin role required`, 'cancelled');
                }
            });

            window.evem.subscribe('admin.action', (event) => {
                log(`<span class="success">Executing admin action:</span> ${event.data.action}`, 'success');
            });

            log('Permission system setup complete', 'info');
        };

        window.adminAction = async () => {
            await window.evem.publishCancelable('admin.action', {
                role: 'admin',
                action: 'Delete user database'
            });
        };

        window.userAction = async () => {
            await window.evem.publishCancelable('admin.action', {
                role: 'user',
                action: 'Delete user database'
            });
        };

        window.setupErrorRecovery = () => {
            window.evem.events.set('api.call', new Map());

            window.evem.subscribe('api.call', async (data) => {
                log('Attempting primary API...', 'info');
                throw new Error('Primary API unavailable');
            });

            window.evem.subscribe('api.call', async (data) => {
                log('Attempting fallback API...', 'info');
                log('<span class="success">Fallback API succeeded!</span>', 'success');
            });

            log('Error recovery setup complete', 'info');
        };

        window.triggerRecovery = async () => {
            log('Making API call...', 'info');
            await window.evem.publish('api.call', { endpoint: '/users' });
        };

        // Initialize
        log('EvEm Cancelable Events & Errors Demo loaded. Click buttons to test features!', 'info');
        updateStats();
    </script>
</body>
</html>
